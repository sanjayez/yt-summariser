# Generated by Django 5.2.3 on 2025-07-10 02:45

from django.db import migrations
import re


def extract_video_id_from_url(url: str) -> str:
    """
    Extract video ID from YouTube URL using multiple methods.
    Based on existing logic in the codebase.
    """
    if not url:
        return None
    
    try:
        # Method 1: Simple string parsing (matches ScrapeTubeProvider logic)
        if "youtube.com/watch?v=" in url:
            return url.split("v=")[1].split("&")[0]
        elif "youtu.be/" in url:
            return url.split("youtu.be/")[1].split("?")[0]
        
        # Method 2: Regex fallback (using the existing pattern from validators.py)
        YOUTUBE_URL_REGEX = re.compile(
            r'(https?://)?(www\.)?(youtube|youtu|youtube-nocookie)\.(com|be)/'
            r'(watch\?v=|embed/|v/|.+\?v=)?([^&=%\?]{11})'
        )
        match = YOUTUBE_URL_REGEX.match(url)
        if match:
            return match.group(6)  # The video ID is in the 6th group
        
        return None
        
    except Exception as e:
        print(f"Error extracting video ID from URL {url}: {str(e)}")
        return None


def generate_fallback_video_id(url_request_id: int) -> str:
    """
    Generate a fallback video ID for cases where extraction fails.
    Uses the URLRequestTable ID to ensure uniqueness.
    """
    return f"fallback_{url_request_id}"


def populate_missing_video_ids(apps, schema_editor):
    """
    Populate missing video_id fields in VideoMetadata table
    """
    VideoMetadata = apps.get_model('video_processor', 'VideoMetadata')
    URLRequestTable = apps.get_model('api', 'URLRequestTable')
    
    # Find VideoMetadata records with missing video_id
    missing_video_ids = VideoMetadata.objects.filter(
        video_id__isnull=True
    ).select_related('url_request')
    
    updated_count = 0
    failed_count = 0
    
    for metadata in missing_video_ids:
        try:
            # Get the original URL from URLRequestTable
            url = metadata.url_request.url
            
            # Extract video ID from URL
            video_id = extract_video_id_from_url(url)
            
            if video_id:
                # Check if this video_id already exists (handle duplicates)
                existing_metadata = VideoMetadata.objects.filter(video_id=video_id).first()
                if existing_metadata and existing_metadata.id != metadata.id:
                    # Video ID already exists, create a unique fallback
                    video_id = generate_fallback_video_id(metadata.url_request.id)
                    print(f"Duplicate video_id found, using fallback: {video_id}")
                
                # Update the record
                metadata.video_id = video_id
                metadata.save()
                updated_count += 1
                print(f"Updated VideoMetadata {metadata.id} with video_id: {video_id}")
                
            else:
                # Could not extract video ID, use fallback
                video_id = generate_fallback_video_id(metadata.url_request.id)
                metadata.video_id = video_id
                metadata.save()
                failed_count += 1
                print(f"Failed to extract video_id from URL {url}, using fallback: {video_id}")
                
        except Exception as e:
            print(f"Error processing VideoMetadata {metadata.id}: {str(e)}")
            failed_count += 1
    
    print(f"Migration completed: {updated_count} records updated, {failed_count} used fallback IDs")


def reverse_populate_missing_video_ids(apps, schema_editor):
    """
    Reverse migration - set video_id back to None for fallback IDs
    """
    VideoMetadata = apps.get_model('video_processor', 'VideoMetadata')
    
    # Find records with fallback video IDs
    fallback_records = VideoMetadata.objects.filter(video_id__startswith='fallback_')
    
    for record in fallback_records:
        record.video_id = None
        record.save()
        print(f"Reverted VideoMetadata {record.id} video_id to None")


class Migration(migrations.Migration):

    dependencies = [
        ('video_processor', '0010_videometadata_is_embedded_videotranscript_key_points_and_more'),
        ('api', '0003_urlrequesttable_search_request'),
    ]

    operations = [
        migrations.RunPython(
            populate_missing_video_ids,
            reverse_populate_missing_video_ids,
            elidable=True,
        ),
    ]